diff -ur kdelibs-4.13.3-orig/kdeui/util/kcrash.cpp kdelibs-4.13.3/kdeui/util/kcrash.cpp
--- kdelibs-4.13.3-orig/kdeui/util/kcrash.cpp	2014-07-11 15:42:13.000000000 +0900
+++ kdelibs-4.13.3/kdeui/util/kcrash.cpp	2014-09-20 15:20:58.000000000 +0900
@@ -313,7 +313,13 @@
         crashRecursionCounter++;
     }
 
-#if !defined(Q_OS_WIN)
+    // On Apple OS X, closing all FDs now will cause a second (SIGILL) crash,
+    // ending with "Unable to start Dr. Konqi". This is because the libdispatch
+    // library, which can manage multi-threading, has some FDs of its own.
+    //
+    // Note: KCrash closes FDs unconditionally later on if it forks to Dr Konqi
+    //       and this program's FDs do not matter if kdeinit starts Dr Konqi.
+#if !defined(Q_OS_WIN) and !defined(Q_OS_MAC)
     if (!(s_flags & KeepFDs))
         closeAllFDs();
 # if defined(Q_WS_X11)
@@ -520,9 +526,12 @@
     // This is done because it is dangerous to use fork() in the crash handler
     // (there can be functions registered to be performed before fork(), for example handling
     // of malloc locking, which doesn't work when malloc crashes because of heap corruption).
+#ifndef Q_OS_MAC
+    // Fails on Apple OSX+KDE4, because kdeinit4 is using the wrong socket name.
     if (!(s_flags & AlwaysDirectly)) {
         startDirectly = !startProcessInternal(argc, argv, waitAndExit, false);
     }
+#endif
 
     // If we can't reach kdeinit, we can still at least try to fork()
     if (startDirectly) {
@@ -805,7 +814,8 @@
 
   server.sun_family = AF_UNIX;
   strcpy(server.sun_path, sock_file);
-  printf("sock_file=%s\n", sock_file);
+  // Use stderr, to make the message visible on the Apple OS X Console log.
+  fprintf(stderr, "KCrash: Connect sock_file=%s\n", sock_file);
   socklen = sizeof(server);
   if(connect(s, (struct sockaddr *)&server, socklen) == -1)
   {
